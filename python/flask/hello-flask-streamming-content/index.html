<html>

  <head lang="ja">
    <title>Flaskのストリーミングを利用してみる</title>
    <meta charSet="utf-8" />
    <meta name="keywords" content="python,flask,streaming" />
    <meta name="description" content="ジェネレーターを利用して文字列のストリーミングを試す" />
    <meta name="copyright" content="@Himenon" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@Himenon" />
    <meta property="og:title" content="Flaskのストリーミングを利用してみる" />
    <meta property="og:url" content="https://himenon.github.io/python/flask/hello-flask-streamming-content" />
    <meta property="og:description" content="ジェネレーターを利用して文字列のストリーミングを試す" />
    <meta property="og:image" content="https://himenon.github.io/assets/images/miku.png" />
    <meta name="viewport" content="initial-scale=1,minimum-scale=0.5,user-scalable=no" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/miku.png?63941" />
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png?0211a" />
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png?578b9" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:600,800?43ee8" rel="stylesheet" />
    <link href="/lib/prism.css?b03cf" rel="stylesheet" />
    <link href="/assets/stylesheets/styles.css?8efef" rel="stylesheet" />
    <script>
      (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function() {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-55455343-7', 'auto');
      ga('send', 'pageview');
    </script>
    <script id="csr-props" data-csr-props="{&quot;htmlMetaData&quot;:{&quot;lang&quot;:&quot;ja&quot;,&quot;title&quot;:&quot;Flaskのストリーミングを利用してみる&quot;,&quot;description&quot;:&quot;ジェネレーターを利用して文字列のストリーミングを試す&quot;,&quot;keywords&quot;:&quot;python,flask,streaming&quot;,&quot;copyright&quot;:&quot;@Himenon&quot;,&quot;viewport&quot;:{&quot;initial-scale&quot;:1,&quot;minimum-scale&quot;:0.5,&quot;user-scalable&quot;:&quot;no&quot;},&quot;thirdParty&quot;:{&quot;googleAnalytics&quot;:{&quot;ua&quot;:&quot;UA-55455343-7&quot;}},&quot;js&quot;:[],&quot;css&quot;:[&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;./node_modules/prismjs/themes/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;link&quot;:[{&quot;rel&quot;:&quot;apple-touch-icon&quot;,&quot;sizes&quot;:&quot;180x180&quot;,&quot;href&quot;:&quot;assets/images/miku.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;32x32&quot;,&quot;href&quot;:&quot;assets/images/favicon-32x32.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;16x16&quot;,&quot;href&quot;:&quot;assets/images/favicon-16x16.png&quot;}],&quot;createdAt&quot;:&quot;2018-03-09T11:40:20.000Z&quot;,&quot;updatedAt&quot;:&quot;2019-05-21T11:22:01.000Z&quot;,&quot;globalScripts&quot;:[],&quot;globalLinks&quot;:[{&quot;rel&quot;:&quot;apple-touch-icon&quot;,&quot;sizes&quot;:&quot;180x180&quot;,&quot;href&quot;:&quot;/assets/images/miku.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;32x32&quot;,&quot;href&quot;:&quot;/assets/images/favicon-32x32.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;16x16&quot;,&quot;href&quot;:&quot;/assets/images/favicon-16x16.png&quot;},&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;/lib/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;localLinks&quot;:[],&quot;extend&quot;:{&quot;meta&quot;:[{&quot;name&quot;:&quot;twitter:card&quot;,&quot;content&quot;:&quot;summary&quot;},{&quot;name&quot;:&quot;twitter:site&quot;,&quot;content&quot;:&quot;@Himenon&quot;},{&quot;property&quot;:&quot;og:title&quot;,&quot;content&quot;:&quot;Flaskのストリーミングを利用してみる&quot;},{&quot;property&quot;:&quot;og:url&quot;,&quot;content&quot;:&quot;https://himenon.github.io/python/flask/hello-flask-streamming-content&quot;},{&quot;property&quot;:&quot;og:description&quot;,&quot;content&quot;:&quot;ジェネレーターを利用して文字列のストリーミングを試す&quot;},{&quot;property&quot;:&quot;og:image&quot;,&quot;content&quot;:&quot;https://himenon.github.io/assets/images/miku.png&quot;}]}},&quot;page&quot;:{&quot;uri&quot;:&quot;/python/flask/hello-flask-streamming-content&quot;,&quot;content&quot;:&quot;\n# Flaskのストリーミングを利用してみる\n\nFlaskにStreaming Contentsというものが存在したので、\nこの実装方法を見てみる。\n\n- &lt;http://flask.pocoo.org/docs/0.12/patterns/streaming/&gt;\n\n## 基本\n\n本記事中では[サンプルコード](https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0)\nの一部を使って解説しながら進めていくので、サンプルコードを適宜参照してほしい。\n\nまずは、コードを書いてみる。適当なディレクトリ(ここでは`myapp`)に`server.py`を用意する。\n\n```python\n@app.route(&#x27;/hello-world&#x27;)\ndef hello_world():\n    def generate():\n        for comment in get_comments():\n            yield &#x27;&lt;li&gt;&#x27; + comment + &#x27;&lt;/li&gt;&#x27;\n            time.sleep(0.5)  # 動作をわかりやすくするために追加\n    return Response(generate())\n```\n\n実行すると次のようになった。\n\n![Google ChromeにおけるStreamingの実際の動画](images/hello-world-streaming.gif)\n\n手元の環境で確認したところ、ChromeとFirefoxでは動画のような挙動になったが、\nSafariはローディングが長くなっただけの、同期的な場合と同じ結果になった。\nどうやら、ブラウザごとにローディングの仕組みが異なるようである。\n\n### 何が起きた？\n\nResponseの第一引数(もしくは`response=`)は、StringかIteratorを受け取る。\nそこにGeneratorを渡すことによって、ストリーミングすることが可能となる。\nこれは[PEP333(日本語訳)のBuffering and Streaming](https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming)に次のように決められている。\n\n&gt; しかしながら、大きいファイル、または HTTP ストリーミングの特殊な用途 (複合「サーバプッシュ」など) のために、アプリケーションは出力をより小さ なブロックに提供する必要があるかもしれない (例えばメモリに大きいファイ ルをロードすることを避けるため)。また、応答のある部分を生成するのに時間 がかかる場合も時々あるが、それに先行するレスポンスの部分を前もって送る ことは役に立つだろう。\n&gt; これらの場合では、通常、アプリケーションはブロックごとの様式で出力を生 成するイテレータ (しばしばジェネレータ・イテレータ) を返すだろう。これ らのブロックは、 mulitpart 境界 (「サーバプッシュ」のための) や、時間の かかるタスク (ディスクに存在するファイルの別のブロックを読むなど) のす ぐ前で分割が起こるかもしれない。\n&gt; 引用：[PEP333(日本語訳)のBuffering and Streaming](https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming)\n\nつまり、\n巨大、もしくは大量のデータを送信する時、ストリーミングを利用すれば、サーバー側のメモリーの使用量が押さえられるから、\nそのような場合に使うために用意されている。（ただし、トレードオフとして転送時間が同期的なレスポンスの場合よりも長くなる）。\n\nただし、この仕様はMUSTではないため、他のWSGIミドルウェアが対応していない場合もあるので、注意したほうがよさそう。\n\n## テンプレートを使う\n\nJinja2のテンプレートを使った場合のストリーミングの実装を見てみる。\nまずはテンプレートの用意をする。\nFlaskのテンプレートは次のようなディレクトリに配置しておけば良い。\n全体のコードは[サンプルコード](https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0)から適宜取得して欲しい。\n\n```\nmyapp/\n├── server.py\n└── templates\n    └── comment_list.html  # 追加\n```\n\nまずは、&lt;http://flask.pocoo.org/docs/0.12/patterns/streaming/&gt;に書いてあるコードを真似してみる。\n\n```python\ndef stream_template(template_name, **context):\n    app.update_template_context(context)\n    t = app.jinja_env.get_template(template_name)   # jinja2.Template\n    rv = t.stream(context)                          # jinja2.environment.TemplateStream \n    rv.enable_buffering(5)\n    return rv\n\n@app.route(&#x27;/hello-world-with-template&#x27;)\ndef hello_world_with_template():\n    return Response(stream_template(&#x27;comment_list.html&#x27;, comments=get_comments()))\n```\n\n`/hello-world-with-template`にアクセスすれば、レンダリングされていることが分かる。\nが、`time.sleep`を入れる場所がないのでもう少し深ぼってみる\n\n### jinja2.Templateの挙動を確認する\n\nテンプレートエンジンはJinja2を利用するため、読むべきAPIドキュメントはJinja2の方。\n\n- http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template\n\n`jinja2.environment.TemplateStream`の挙動を検証する。\n`templates`が存在する、`myapp/`の中でipythonを叩いてみる。\n\n```python\nfrom flask import Flask\napp = Flask(&#x27;hello&#x27;)\n\ncontext = {\n    &#x27;comments&#x27;: [ &#x27;Count: {}&#x27;.format(i) for i in range(100) ]\n}\napp.update_template_context(context)\nt = app.jinja_env.get_template(&#x27;comment_list.html&#x27;)\n\nrv = t.stream(context) # jinja2.environment.TemplateStream\nrv.enable_buffering(5) # バッファサイズ\n\nnext(rv) # listの1〜5  まで\nnext(rv) # listの6〜11 まで\n# ...\n```\n\n`jinja2.environment.TemplateStream`は`enable_buffering`で指定された\n大きさにチャンクされたイテレータ化されてくる（`__iter__`を持っている)。\n\nこれを逆手に取って、どの様にレンダリングされていくか、確認するため似、次のようにコードを書き換えてみる。\n\n```python\ndef stream_template(template_name, **context):\n    app.update_template_context(context)\n    t = app.jinja_env.get_template(template_name)\n    rv = t.stream(context)\n    rv.enable_buffering(5)\n    for buffer in rv:\n        yield buffer\n        time.sleep(0.5)\n```\n\nこれを実行すると、次のような結果になった。\n\n![テンプレートエンジンを使った場合の挙動](images/hello-world-streaming-with-template.gif)\n\nやはりResponseにイテレータを渡していることがわかった。\n\n## stream_with_context\n\nGeneratorの中でリクエストに含まれるパラメータを取得したい場合がある。\ngenerator中では`flask.requrest`にアクセスできないため、それを可能にするために、\n`stream_with_context`を利用する。これを利用することにより、\n`flask.request`にアクセスすることができる。\n\n```python\n@app.route(&#x27;/stream&#x27;)\ndef streamed_response():\n    def generate():\n        yield &#x27;Hello &#x27;\n        time.sleep(1)\n        yield request.args[&#x27;name&#x27;] # stream_with_contextでwrapされてるためアクセウ可\n        time.sleep(1)\n        yield &#x27;!&#x27;\n\n    return Response(stream_with_context(generate()))\n```\n\n## 所感\n\nPEP333に書いてあるとおり、データ容量の大きなデータを送信する場合に使えることがわかる。\n数MB、もしくは数GB単位のデータをウェブサイトからダウンロードする時、サーバー側に負荷をかけないためにも\nこのパターンは使えそうである。\n\n**参考**\n\n本文中で出てきたリンクをまとめておく。\n\n- サンプルコード: &lt;https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0&gt;\n- Flask Streaming Content: &lt;http://flask.pocoo.org/docs/0.12/patterns/streaming/&gt;\n- PEP333: &lt;https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming&gt;\n- Jinja2: &lt;http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template&gt;\n\n\n\n\n&quot;,&quot;metaData&quot;:{&quot;lang&quot;:&quot;ja&quot;,&quot;title&quot;:&quot;Flaskのストリーミングを利用してみる&quot;,&quot;description&quot;:&quot;ジェネレーターを利用して文字列のストリーミングを試す&quot;,&quot;keywords&quot;:&quot;python,flask,streaming&quot;,&quot;copyright&quot;:&quot;@Himenon&quot;,&quot;viewport&quot;:{&quot;initial-scale&quot;:1,&quot;minimum-scale&quot;:0.5,&quot;user-scalable&quot;:&quot;no&quot;},&quot;thirdParty&quot;:{&quot;googleAnalytics&quot;:{&quot;ua&quot;:&quot;UA-55455343-7&quot;}},&quot;js&quot;:[],&quot;css&quot;:[&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;./node_modules/prismjs/themes/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;link&quot;:[{&quot;rel&quot;:&quot;apple-touch-icon&quot;,&quot;sizes&quot;:&quot;180x180&quot;,&quot;href&quot;:&quot;assets/images/miku.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;32x32&quot;,&quot;href&quot;:&quot;assets/images/favicon-32x32.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;16x16&quot;,&quot;href&quot;:&quot;assets/images/favicon-16x16.png&quot;}],&quot;createdAt&quot;:&quot;2018-03-09T11:40:20.000Z&quot;,&quot;updatedAt&quot;:&quot;2019-05-21T11:22:01.000Z&quot;,&quot;globalScripts&quot;:[],&quot;globalLinks&quot;:[{&quot;rel&quot;:&quot;apple-touch-icon&quot;,&quot;sizes&quot;:&quot;180x180&quot;,&quot;href&quot;:&quot;/assets/images/miku.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;32x32&quot;,&quot;href&quot;:&quot;/assets/images/favicon-32x32.png&quot;},{&quot;rel&quot;:&quot;icon&quot;,&quot;type&quot;:&quot;image/png&quot;,&quot;sizes&quot;:&quot;16x16&quot;,&quot;href&quot;:&quot;/assets/images/favicon-16x16.png&quot;},&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;/lib/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;localLinks&quot;:[],&quot;extend&quot;:{&quot;meta&quot;:[{&quot;name&quot;:&quot;twitter:card&quot;,&quot;content&quot;:&quot;summary&quot;},{&quot;name&quot;:&quot;twitter:site&quot;,&quot;content&quot;:&quot;@Himenon&quot;},{&quot;property&quot;:&quot;og:title&quot;,&quot;content&quot;:&quot;Flaskのストリーミングを利用してみる&quot;},{&quot;property&quot;:&quot;og:url&quot;,&quot;content&quot;:&quot;https://himenon.github.io/python/flask/hello-flask-streamming-content&quot;},{&quot;property&quot;:&quot;og:description&quot;,&quot;content&quot;:&quot;ジェネレーターを利用して文字列のストリーミングを試す&quot;},{&quot;property&quot;:&quot;og:image&quot;,&quot;content&quot;:&quot;https://himenon.github.io/assets/images/miku.png&quot;}]}},&quot;ext&quot;:&quot;.md&quot;,&quot;filename&quot;:&quot;src/python/flask/hello-flask-streamming-content.md&quot;,&quot;name&quot;:&quot;python/flask/hello-flask-streamming-content&quot;,&quot;raw&quot;:&quot;---\ntitle: \&quot;Flaskのストリーミングを利用してみる\&quot;\ndescription: \&quot;ジェネレーターを利用して文字列のストリーミングを試す\&quot;\nkeywords: \&quot;python,flask,streaming\&quot;\ncreatedAt: 2018-03-09 11:40:20\nupdatedAt: 2019-05-21 11:22:01\n---\n\n# Flaskのストリーミングを利用してみる\n\nFlaskにStreaming Contentsというものが存在したので、\nこの実装方法を見てみる。\n\n- &lt;http://flask.pocoo.org/docs/0.12/patterns/streaming/&gt;\n\n## 基本\n\n本記事中では[サンプルコード](https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0)\nの一部を使って解説しながら進めていくので、サンプルコードを適宜参照してほしい。\n\nまずは、コードを書いてみる。適当なディレクトリ(ここでは`myapp`)に`server.py`を用意する。\n\n```python\n@app.route(&#x27;/hello-world&#x27;)\ndef hello_world():\n    def generate():\n        for comment in get_comments():\n            yield &#x27;&lt;li&gt;&#x27; + comment + &#x27;&lt;/li&gt;&#x27;\n            time.sleep(0.5)  # 動作をわかりやすくするために追加\n    return Response(generate())\n```\n\n実行すると次のようになった。\n\n![Google ChromeにおけるStreamingの実際の動画](images/hello-world-streaming.gif)\n\n手元の環境で確認したところ、ChromeとFirefoxでは動画のような挙動になったが、\nSafariはローディングが長くなっただけの、同期的な場合と同じ結果になった。\nどうやら、ブラウザごとにローディングの仕組みが異なるようである。\n\n### 何が起きた？\n\nResponseの第一引数(もしくは`response=`)は、StringかIteratorを受け取る。\nそこにGeneratorを渡すことによって、ストリーミングすることが可能となる。\nこれは[PEP333(日本語訳)のBuffering and Streaming](https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming)に次のように決められている。\n\n&gt; しかしながら、大きいファイル、または HTTP ストリーミングの特殊な用途 (複合「サーバプッシュ」など) のために、アプリケーションは出力をより小さ なブロックに提供する必要があるかもしれない (例えばメモリに大きいファイ ルをロードすることを避けるため)。また、応答のある部分を生成するのに時間 がかかる場合も時々あるが、それに先行するレスポンスの部分を前もって送る ことは役に立つだろう。\n&gt; これらの場合では、通常、アプリケーションはブロックごとの様式で出力を生 成するイテレータ (しばしばジェネレータ・イテレータ) を返すだろう。これ らのブロックは、 mulitpart 境界 (「サーバプッシュ」のための) や、時間の かかるタスク (ディスクに存在するファイルの別のブロックを読むなど) のす ぐ前で分割が起こるかもしれない。\n&gt; 引用：[PEP333(日本語訳)のBuffering and Streaming](https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming)\n\nつまり、\n巨大、もしくは大量のデータを送信する時、ストリーミングを利用すれば、サーバー側のメモリーの使用量が押さえられるから、\nそのような場合に使うために用意されている。（ただし、トレードオフとして転送時間が同期的なレスポンスの場合よりも長くなる）。\n\nただし、この仕様はMUSTではないため、他のWSGIミドルウェアが対応していない場合もあるので、注意したほうがよさそう。\n\n## テンプレートを使う\n\nJinja2のテンプレートを使った場合のストリーミングの実装を見てみる。\nまずはテンプレートの用意をする。\nFlaskのテンプレートは次のようなディレクトリに配置しておけば良い。\n全体のコードは[サンプルコード](https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0)から適宜取得して欲しい。\n\n```\nmyapp/\n├── server.py\n└── templates\n    └── comment_list.html  # 追加\n```\n\nまずは、&lt;http://flask.pocoo.org/docs/0.12/patterns/streaming/&gt;に書いてあるコードを真似してみる。\n\n```python\ndef stream_template(template_name, **context):\n    app.update_template_context(context)\n    t = app.jinja_env.get_template(template_name)   # jinja2.Template\n    rv = t.stream(context)                          # jinja2.environment.TemplateStream \n    rv.enable_buffering(5)\n    return rv\n\n@app.route(&#x27;/hello-world-with-template&#x27;)\ndef hello_world_with_template():\n    return Response(stream_template(&#x27;comment_list.html&#x27;, comments=get_comments()))\n```\n\n`/hello-world-with-template`にアクセスすれば、レンダリングされていることが分かる。\nが、`time.sleep`を入れる場所がないのでもう少し深ぼってみる\n\n### jinja2.Templateの挙動を確認する\n\nテンプレートエンジンはJinja2を利用するため、読むべきAPIドキュメントはJinja2の方。\n\n- http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template\n\n`jinja2.environment.TemplateStream`の挙動を検証する。\n`templates`が存在する、`myapp/`の中でipythonを叩いてみる。\n\n```python\nfrom flask import Flask\napp = Flask(&#x27;hello&#x27;)\n\ncontext = {\n    &#x27;comments&#x27;: [ &#x27;Count: {}&#x27;.format(i) for i in range(100) ]\n}\napp.update_template_context(context)\nt = app.jinja_env.get_template(&#x27;comment_list.html&#x27;)\n\nrv = t.stream(context) # jinja2.environment.TemplateStream\nrv.enable_buffering(5) # バッファサイズ\n\nnext(rv) # listの1〜5  まで\nnext(rv) # listの6〜11 まで\n# ...\n```\n\n`jinja2.environment.TemplateStream`は`enable_buffering`で指定された\n大きさにチャンクされたイテレータ化されてくる（`__iter__`を持っている)。\n\nこれを逆手に取って、どの様にレンダリングされていくか、確認するため似、次のようにコードを書き換えてみる。\n\n```python\ndef stream_template(template_name, **context):\n    app.update_template_context(context)\n    t = app.jinja_env.get_template(template_name)\n    rv = t.stream(context)\n    rv.enable_buffering(5)\n    for buffer in rv:\n        yield buffer\n        time.sleep(0.5)\n```\n\nこれを実行すると、次のような結果になった。\n\n![テンプレートエンジンを使った場合の挙動](images/hello-world-streaming-with-template.gif)\n\nやはりResponseにイテレータを渡していることがわかった。\n\n## stream_with_context\n\nGeneratorの中でリクエストに含まれるパラメータを取得したい場合がある。\ngenerator中では`flask.requrest`にアクセスできないため、それを可能にするために、\n`stream_with_context`を利用する。これを利用することにより、\n`flask.request`にアクセスすることができる。\n\n```python\n@app.route(&#x27;/stream&#x27;)\ndef streamed_response():\n    def generate():\n        yield &#x27;Hello &#x27;\n        time.sleep(1)\n        yield request.args[&#x27;name&#x27;] # stream_with_contextでwrapされてるためアクセウ可\n        time.sleep(1)\n        yield &#x27;!&#x27;\n\n    return Response(stream_with_context(generate()))\n```\n\n## 所感\n\nPEP333に書いてあるとおり、データ容量の大きなデータを送信する場合に使えることがわかる。\n数MB、もしくは数GB単位のデータをウェブサイトからダウンロードする時、サーバー側に負荷をかけないためにも\nこのパターンは使えそうである。\n\n**参考**\n\n本文中で出てきたリンクをまとめておく。\n\n- サンプルコード: &lt;https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0&gt;\n- Flask Streaming Content: &lt;http://flask.pocoo.org/docs/0.12/patterns/streaming/&gt;\n- PEP333: &lt;https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming&gt;\n- Jinja2: &lt;http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template&gt;\n\n\n\n\n&quot;},&quot;site&quot;:{&quot;title&quot;:&quot;himenon.github.io&quot;,&quot;description&quot;:&quot;早く画面から出たい人の備忘録。&quot;,&quot;baseUri&quot;:&quot;/&quot;,&quot;baseUrl&quot;:&quot;https://himenon.github.io&quot;}}"></script>
  </head>

  <body>

    <body>
      <div>
        <nav id="nav-bar">
          <div id="nav-bar-container"><a href="/">TOP</a></div>
        </nav>
        <header id="site-header">
          <div id="site-header-container">
            <h1 id="page-title">Flaskのストリーミングを利用してみる</h1>
            <p id="page-description">ジェネレーターを利用して文字列のストリーミングを試す</p>
            <p id="article-time"><span id="posted-at__label">投稿日</span><time>2018-03-09 08:40:20</time><span id="created-at__label">更新日</span><time>2019-05-21 08:22:01</time></p>
          </div>
        </header>
      </div>
      <div class="wrapper">
        <section>
          <h1>Flaskのストリーミングを利用してみる</h1>
          <p>FlaskにStreaming Contentsというものが存在したので、
            この実装方法を見てみる。</p>
          <ul>
            <li><a href="http://flask.pocoo.org/docs/0.12/patterns/streaming/">http://flask.pocoo.org/docs/0.12/patterns/streaming/</a></li>
          </ul>
          <h2>基本</h2>
          <p>本記事中では<a href="https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0">サンプルコード</a>
            の一部を使って解説しながら進めていくので、サンプルコードを適宜参照してほしい。</p>
          <p>まずは、コードを書いてみる。適当なディレクトリ(ここでは<code>myapp</code>)に<code>server.py</code>を用意する。</p><pre class="language-python"><code class="language-python"><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/hello-world'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> comment <span class="token keyword">in</span> get_comments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">yield</span> <span class="token string">'&lt;li>'</span> <span class="token operator">+</span> comment <span class="token operator">+</span> <span class="token string">'&lt;/li>'</span>
            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>  <span class="token comment"># 動作をわかりやすくするために追加</span>
    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>generate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
          <p>実行すると次のようになった。</p>
          <p><img src="/python/flask/images/hello-world-streaming.gif" alt="Google ChromeにおけるStreamingの実際の動画" /></p>
          <p>手元の環境で確認したところ、ChromeとFirefoxでは動画のような挙動になったが、
            Safariはローディングが長くなっただけの、同期的な場合と同じ結果になった。
            どうやら、ブラウザごとにローディングの仕組みが異なるようである。</p>
          <h3>何が起きた？</h3>
          <p>Responseの第一引数(もしくは<code>response=</code>)は、StringかIteratorを受け取る。
            そこにGeneratorを渡すことによって、ストリーミングすることが可能となる。
            これは<a href="https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming">PEP333(日本語訳)のBuffering and Streaming</a>に次のように決められている。</p>
          <blockquote>
            <p>しかしながら、大きいファイル、または HTTP ストリーミングの特殊な用途 (複合「サーバプッシュ」など) のために、アプリケーションは出力をより小さ なブロックに提供する必要があるかもしれない (例えばメモリに大きいファイ ルをロードすることを避けるため)。また、応答のある部分を生成するのに時間 がかかる場合も時々あるが、それに先行するレスポンスの部分を前もって送る ことは役に立つだろう。
              これらの場合では、通常、アプリケーションはブロックごとの様式で出力を生 成するイテレータ (しばしばジェネレータ・イテレータ) を返すだろう。これ らのブロックは、 mulitpart 境界 (「サーバプッシュ」のための) や、時間の かかるタスク (ディスクに存在するファイルの別のブロックを読むなど) のす ぐ前で分割が起こるかもしれない。
              引用：<a href="https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming">PEP333(日本語訳)のBuffering and Streaming</a></p>
          </blockquote>
          <p>つまり、
            巨大、もしくは大量のデータを送信する時、ストリーミングを利用すれば、サーバー側のメモリーの使用量が押さえられるから、
            そのような場合に使うために用意されている。（ただし、トレードオフとして転送時間が同期的なレスポンスの場合よりも長くなる）。</p>
          <p>ただし、この仕様はMUSTではないため、他のWSGIミドルウェアが対応していない場合もあるので、注意したほうがよさそう。</p>
          <h2>テンプレートを使う</h2>
          <p>Jinja2のテンプレートを使った場合のストリーミングの実装を見てみる。
            まずはテンプレートの用意をする。
            Flaskのテンプレートは次のようなディレクトリに配置しておけば良い。
            全体のコードは<a href="https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0">サンプルコード</a>から適宜取得して欲しい。</p><pre class="language-plain"><code class="language-plain">myapp/
├── server.py
└── templates
    └── comment_list.html  # 追加
</code></pre>
          <p>まずは、<a href="http://flask.pocoo.org/docs/0.12/patterns/streaming/">http://flask.pocoo.org/docs/0.12/patterns/streaming/</a>に書いてあるコードを真似してみる。</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">stream_template</span><span class="token punctuation">(</span>template_name<span class="token punctuation">,</span> <span class="token operator">**</span>context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>update_template_context<span class="token punctuation">(</span>context<span class="token punctuation">)</span>
    t <span class="token operator">=</span> app<span class="token punctuation">.</span>jinja_env<span class="token punctuation">.</span>get_template<span class="token punctuation">(</span>template_name<span class="token punctuation">)</span>   <span class="token comment"># jinja2.Template</span>
    rv <span class="token operator">=</span> t<span class="token punctuation">.</span>stream<span class="token punctuation">(</span>context<span class="token punctuation">)</span>                          <span class="token comment"># jinja2.environment.TemplateStream </span>
    rv<span class="token punctuation">.</span>enable_buffering<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> rv

@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/hello-world-with-template'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hello_world_with_template</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>stream_template<span class="token punctuation">(</span><span class="token string">'comment_list.html'</span><span class="token punctuation">,</span> comments<span class="token operator">=</span>get_comments<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
          <p><code>/hello-world-with-template</code>にアクセスすれば、レンダリングされていることが分かる。
            が、<code>time.sleep</code>を入れる場所がないのでもう少し深ぼってみる</p>
          <h3>jinja2.Templateの挙動を確認する</h3>
          <p>テンプレートエンジンはJinja2を利用するため、読むべきAPIドキュメントはJinja2の方。</p>
          <ul>
            <li><a href="http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template">http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template</a></li>
          </ul>
          <p><code>jinja2.environment.TemplateStream</code>の挙動を検証する。
            <code>templates</code>が存在する、<code>myapp/</code>の中でipythonを叩いてみる。</p><pre class="language-python"><code class="language-python"><span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask
app <span class="token operator">=</span> Flask<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>

context <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">'comments'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'Count: {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
app<span class="token punctuation">.</span>update_template_context<span class="token punctuation">(</span>context<span class="token punctuation">)</span>
t <span class="token operator">=</span> app<span class="token punctuation">.</span>jinja_env<span class="token punctuation">.</span>get_template<span class="token punctuation">(</span><span class="token string">'comment_list.html'</span><span class="token punctuation">)</span>

rv <span class="token operator">=</span> t<span class="token punctuation">.</span>stream<span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token comment"># jinja2.environment.TemplateStream</span>
rv<span class="token punctuation">.</span>enable_buffering<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment"># バッファサイズ</span>

<span class="token builtin">next</span><span class="token punctuation">(</span>rv<span class="token punctuation">)</span> <span class="token comment"># listの1〜5  まで</span>
<span class="token builtin">next</span><span class="token punctuation">(</span>rv<span class="token punctuation">)</span> <span class="token comment"># listの6〜11 まで</span>
<span class="token comment"># ...</span>
</code></pre>
          <p><code>jinja2.environment.TemplateStream</code>は<code>enable_buffering</code>で指定された
            大きさにチャンクされたイテレータ化されてくる（<code>__iter__</code>を持っている)。</p>
          <p>これを逆手に取って、どの様にレンダリングされていくか、確認するため似、次のようにコードを書き換えてみる。</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">stream_template</span><span class="token punctuation">(</span>template_name<span class="token punctuation">,</span> <span class="token operator">**</span>context<span class="token punctuation">)</span><span class="token punctuation">:</span>
    app<span class="token punctuation">.</span>update_template_context<span class="token punctuation">(</span>context<span class="token punctuation">)</span>
    t <span class="token operator">=</span> app<span class="token punctuation">.</span>jinja_env<span class="token punctuation">.</span>get_template<span class="token punctuation">(</span>template_name<span class="token punctuation">)</span>
    rv <span class="token operator">=</span> t<span class="token punctuation">.</span>stream<span class="token punctuation">(</span>context<span class="token punctuation">)</span>
    rv<span class="token punctuation">.</span>enable_buffering<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token builtin">buffer</span> <span class="token keyword">in</span> rv<span class="token punctuation">:</span>
        <span class="token keyword">yield</span> <span class="token builtin">buffer</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>
</code></pre>
          <p>これを実行すると、次のような結果になった。</p>
          <p><img src="/python/flask/images/hello-world-streaming-with-template.gif" alt="テンプレートエンジンを使った場合の挙動" /></p>
          <p>やはりResponseにイテレータを渡していることがわかった。</p>
          <h2>stream_with_context</h2>
          <p>Generatorの中でリクエストに含まれるパラメータを取得したい場合がある。
            generator中では<code>flask.requrest</code>にアクセスできないため、それを可能にするために、
            <code>stream_with_context</code>を利用する。これを利用することにより、
            <code>flask.request</code>にアクセスすることができる。</p><pre class="language-python"><code class="language-python"><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>route</span><span class="token punctuation">(</span><span class="token string">'/stream'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">streamed_response</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span> <span class="token string">'Hello '</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> request<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token comment"># stream_with_contextでwrapされてるためアクセウ可</span>
        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> <span class="token string">'!'</span>

    <span class="token keyword">return</span> Response<span class="token punctuation">(</span>stream_with_context<span class="token punctuation">(</span>generate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
          <h2>所感</h2>
          <p>PEP333に書いてあるとおり、データ容量の大きなデータを送信する場合に使えることがわかる。
            数MB、もしくは数GB単位のデータをウェブサイトからダウンロードする時、サーバー側に負荷をかけないためにも
            このパターンは使えそうである。</p>
          <p><strong>参考</strong></p>
          <p>本文中で出てきたリンクをまとめておく。</p>
          <ul>
            <li>サンプルコード: <a href="https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0">https://gist.github.com/Himenon/9a4e7dd1a7e57a6da09b2b9624a737a0</a></li>
            <li>Flask Streaming Content: <a href="http://flask.pocoo.org/docs/0.12/patterns/streaming/">http://flask.pocoo.org/docs/0.12/patterns/streaming/</a></li>
            <li>PEP333: <a href="https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming">https://knzm.readthedocs.io/en/latest/pep-0333-ja.html#buffering-and-streaming</a></li>
            <li>Jinja2: <a href="http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template">http://jinja.pocoo.org/docs/2.10/api/#jinja2.Template</a></li>
          </ul>
        </section>
      </div>
    </body>
  </body>

</html>