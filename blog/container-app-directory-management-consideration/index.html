<html>

  <head lang="ja">
    <title>コンテナアプリケーション作成時のディレクトリ成長設計の考察</title>
    <meta charSet="utf-8" />
    <meta name="keywords" content="nodejs,typescript,python,himenon,web,frontend" />
    <meta name="description" content="早くが画面から出たい人の備忘録。" />
    <meta name="copyright" content="@Himenon" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@Himenon" />
    <meta property="og:title" content="コンテナアプリケーション作成時のディレクトリ成長設計の考察" />
    <meta property="og:url" content="https://himenon.github.io/blog/container-app-directory-management-consideration" />
    <meta property="og:description" content="早くが画面から出たい人の備忘録。" />
    <meta property="og:image" content="https://himenon.github.io" />
    <meta name="viewport" content="initial-scale=1,minimum-scale=0.5,user-scalable=no" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:600,800?eeff2" rel="stylesheet" />
    <link href="/lib/prism.css?01ea5" rel="stylesheet" />
    <link href="/assets/stylesheets/styles.css?b256f" rel="stylesheet" />
    <script>
      (function(i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function() {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-55455343-7', 'auto');
      ga('send', 'pageview');
    </script>
    <script id="csr-props" data-csr-props="{&quot;htmlMetaData&quot;:{&quot;lang&quot;:&quot;ja&quot;,&quot;title&quot;:&quot;コンテナアプリケーション作成時のディレクトリ成長設計の考察&quot;,&quot;description&quot;:&quot;早くが画面から出たい人の備忘録。&quot;,&quot;keywords&quot;:&quot;nodejs,typescript,python,himenon,web,frontend&quot;,&quot;copyright&quot;:&quot;@Himenon&quot;,&quot;viewport&quot;:{&quot;initial-scale&quot;:1,&quot;minimum-scale&quot;:0.5,&quot;user-scalable&quot;:&quot;no&quot;},&quot;thirdParty&quot;:{&quot;googleAnalytics&quot;:{&quot;ua&quot;:&quot;UA-55455343-7&quot;}},&quot;js&quot;:[],&quot;css&quot;:[&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;./node_modules/prismjs/themes/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;link&quot;:[],&quot;createdAt&quot;:&quot;2018-03-16T02:28:23.000Z&quot;,&quot;updatedAt&quot;:&quot;2019-05-21T11:22:01.000Z&quot;,&quot;globalScripts&quot;:[],&quot;globalLinks&quot;:[&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;/lib/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;localLinks&quot;:[],&quot;extend&quot;:{&quot;meta&quot;:[{&quot;name&quot;:&quot;twitter:card&quot;,&quot;content&quot;:&quot;summary&quot;},{&quot;name&quot;:&quot;twitter:site&quot;,&quot;content&quot;:&quot;@Himenon&quot;},{&quot;property&quot;:&quot;og:title&quot;,&quot;content&quot;:&quot;コンテナアプリケーション作成時のディレクトリ成長設計の考察&quot;},{&quot;property&quot;:&quot;og:url&quot;,&quot;content&quot;:&quot;https://himenon.github.io/blog/container-app-directory-management-consideration&quot;},{&quot;property&quot;:&quot;og:description&quot;,&quot;content&quot;:&quot;早くが画面から出たい人の備忘録。&quot;},{&quot;property&quot;:&quot;og:image&quot;,&quot;content&quot;:&quot;https://himenon.github.io&quot;}]}},&quot;page&quot;:{&quot;uri&quot;:&quot;/blog/container-app-directory-management-consideration&quot;,&quot;content&quot;:&quot;\n## はじめに\n\nDockerを使ったWEBアプリケーションのディレクトリ成長設計について考えていきます。\n\n### 提起\n\nPCを使う上で、我々の扱うデータはディレクトリ構造の中に格納されています。\nアプリケーション開発は、コーディングして、バージョン管理し、デプロイまで\n行って初めてユーザーに届きます。\n時が経過するに連れて、使用する技術やサービスの規模感が変わってきますが、\nディレクトリ構造の初期設計次第で、迅速に対応できるかどうかが決まってくると考えられます。\n\n### 課題\n\nマイクロサービスアプリケーションにおける、\nコンテナを用いたアプリケーションの\nディレクトリの成長設計の考察を具体的に行う。\n\n### 方向性\n\n「UNIXという考え方―その設計思想と哲学」の本に乗っ取り、\n以下のことを目標に考えていきます。\n\n- 小さく作る\n- 1つのプログラムには1つのことだけをやらせる\n- 試作が早く作れる状態にする\n- 効率より移植性を取る\n- すべてのプログラムをフィルタにする\n\nこれから外れる考えのものははじく方針で行います。\n\n## 解説用のアプリケーションの要件定義\n\n説明のため、予め要件定義をしておきます。\n(問題の抽象度とここの具体度がかけ離れすぎなので、気が向いたら調整)\n\n1. WEBアプリケーションを作成する\n1. 言語はPythonとする\n1. 開発環境はDockerを用いる\n1. デプロイ先はKubernetesとする\n1. KubernetesはHelmによって管理する\n1. CI/CDを用いて、自動テスト、自動デプロイを行う\n1. コードはGithubで管理する\n1. テスト駆動を行う\n1. ドキュメントを必ず残す\n1. マイクロサービスアーキテクチャを採用する\n\n## 具体的な手順に落とし込んで俯瞰する\n\n要件を満たすように、WEBアプリケーションを育ててみます。\nその時のファイル構造、ディレクトリ構造の変化を見ていきます。\nモチベーションの維持のために、「まず動かす」を前提に構築していきます。\n\n### 1. 小さなWEBアプリケーションを作成する\n\n```\n+ server.py\n```\n\nローカルでサクッと試せるアプリケーションのコードを配置します。\nファイル分割とかは後回しです。まず動かす、という部分を達成する。\n\n### 2. テストコードを追加する\n\n```\n  server.py\n+ test_server.py\n```\n\nこの段階ではまだ`test/`ディレクトリを切らないでおく。\n理由は、まずはコンテナで動かすが目標。\n\n### 3. ドキュメントを追加する\n\n```\n  server.py\n  test_server.py\n+ README.md\n```\n\ngit pullしてから、起動、テストを行う方法を書いておいたほうが良いでしょう。\nアプリの想像力の方にリソースを持っていかれるので、忘れないうちに書きます。\n\n### 4. CIの設定を組み込む\n\n```\n+ .ci_settings\n  server.py\n  test_server.py\n  README.md\n```\n\nCircle CIでもTravis CIでも良いので、まず突っ込みます。\nアプリケーションが肥大化する前に設置することが大事です。\n\n### 5. コンテナ化する\n\n```\n  .ci_settings\n+ Dockerfile\n  server.py\n  test_server.py\n  README.md\n```\n\nDockerfileは、このアプリケーションが`docker pull`したあと、\n`docker run`で立ち上がるように記述します。\n\n### 6. git cloneしたあとに立ち上げやすいようにする\n\n```\n  .ci_settings\n  Dockerfile\n+ docker-compose.yml\n  server.py\n  test_server.py\n  README.md\n```\n\n`docker-compose up`もしくは、それと同等のコマンドで、\nミドルウェアも含めたアプリケーションが全て立ち上がると開発への着手がはやい。\n\n### 7. frontendとbackendで切り分ける\n\n```\n  .ci_settings\n+ frontend/\n+   Dockerfile\n+ backend/\n    Dockerfile\n    server.py\n    test_server.py\n  docker-compose.yml # build contextの変更\n  README.md\n```\n\nFrontendとBackendのコードを分離して保守しやすい状態にします。\nマイクロサービスの下地ができました。\n\n### 8. 成長させる\n\n```\n  .ci_settings\n  frontend/\n    Dockerfile\n    ...\n  backend/\n    Dockerfile\n    server.py\n    module/\n      ...\n    test/\n      test_server.py\n  docker-compose.yml # build contextの変更\n  README.md\n```\n\n前回でディレクトリの切り分けが終わったので、あとはそれぞれのマイクロサービスを成長させるだけです。\nそれぞれのマイクロサービスでドメイン設計を行いつつ、\nディレクトリの成長設計をすると、開発者にとってもサービスにとっても良いことしかないでしょう。\n\n## まとめ\n\n成長痛を味わいますが、小さいうちに、手の届く範囲からTDDできる状態に\nディレクトリの成長設計を行っておくことで、\n肥大化するアプリケーションに対して先手を打つことができます。\n\n大規模なOSSを見たり、実際に運用されているコードを見て、\n自らの知識や理論、経験からくる構造設計と照らし合わせながら今後も考察していきたいですね。\n\n## 【余談】Dockerfileの`ENTRYPOINT`と`CMD`に関して、個人的な考察\n\nいろいろ試した結果、要件が確定していない場合や、より明確に実行コマンドを開発者に伝えるには、\n`CMD`と`ENTRYPOINT`の役割を明確化しておく必要があると考えます。\n具体的には次の2つです。\n\n1. `Dockerfile`の最後は`CMD`で終わるようにし、フォアグラウンドプロセスとして起動するようにしておく。\n1. `ENTRYPOINT`は`exec $@`を末尾に記述しておき、環境変数によって、コンテナ内部の状態が切り替わるようにしておく。\n\n比喩を用いて例えると、`CMD`は手で、`ENTRYPOINT`は腕のような感じです。\n\n直接アプリケーションを実行するのは`CMD`にしておき、\n例えば、同一のアプリケーションでも異なる立ち上げ方を試したような場合(引数などをつける)ときに、\n素のコマンドが起動時に伝わったほうが検証が早くなります。\n\n`ENTRYPOINT`の使い方は、先の検証によって導き出された設定を環境変数で切り替えることだけを考えます。\n`ENTRYPOINT`はシェルスクリプトで記述しますが、\n末尾に`exec \&quot;$@\&quot;`をつけることで、`CMD`を実行することが可能です。\nここに至る前までに、環境変数でコンテナ内部の状態を切り替えることで`CMD`の機動力を失わずに、設定を切り替えられます。\n\n1つのアプリケーションが複数の起動コマンドを持っている場合に、この2つに分離しておいたほうが良いことがわかります。\n具体的な例だと、タスクキューライブラリの`celery`を使っている時にこの事象が発生しました。\nCeleryは同一のコードで、`worker`、`scheduler`、`server`の3つの役割をもたせることができます。\n起動コマンドが異なるだけで、それ以外は全く同じです。\n\nこれを環境変数で起動コマンドを切り替えるようにすることも可能ですが、\n結局どんなコマンドで実行していたのかを確認するためには、ロジックを読まないとたどり着けず、\nそれだけで消耗してしまいます。\n\n幸いにして、`CMD`の部分は`docker-compose`は`command`であとから変更できますし、\nKubernetesも同様のことがdeploymentでできます。\n若干Portabilityの部分が下がる印象がありますが、\nそもそもアプリケーションが複数の起動パターンを持っている場合はあとから変更することが可能な状態にしておいたほうが良いと考えられます。\n\n### 反例\n\n反例は有ります。[getredash/redash](https://github.com/getredash/redash)です。\n`bin/docker-entrypoint`に起動ロジックが集約されています。\n`docker-compose.yml`は`command`を受け付けていますが、純粋なcommandではなく、引数になっています。\n(この部分、本当なら`args`を利用したほうが良いように思えますが、\n今後`docker-compose`が主流でなくなった時に`args`があるかどうかわからないのでこれはこれで正解かなと思います。)\nredashの場合、アーキテクチャが既に決まっているようなOSSになっているので、\nユーザー側にむしろ負担を強いいないような設計になっているのかな、と勝手に推測します。\n&quot;,&quot;metaData&quot;:{&quot;lang&quot;:&quot;ja&quot;,&quot;title&quot;:&quot;コンテナアプリケーション作成時のディレクトリ成長設計の考察&quot;,&quot;description&quot;:&quot;早くが画面から出たい人の備忘録。&quot;,&quot;keywords&quot;:&quot;nodejs,typescript,python,himenon,web,frontend&quot;,&quot;copyright&quot;:&quot;@Himenon&quot;,&quot;viewport&quot;:{&quot;initial-scale&quot;:1,&quot;minimum-scale&quot;:0.5,&quot;user-scalable&quot;:&quot;no&quot;},&quot;thirdParty&quot;:{&quot;googleAnalytics&quot;:{&quot;ua&quot;:&quot;UA-55455343-7&quot;}},&quot;js&quot;:[],&quot;css&quot;:[&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;./node_modules/prismjs/themes/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;link&quot;:[],&quot;createdAt&quot;:&quot;2018-03-16T02:28:23.000Z&quot;,&quot;updatedAt&quot;:&quot;2019-05-21T11:22:01.000Z&quot;,&quot;globalScripts&quot;:[],&quot;globalLinks&quot;:[&quot;https://fonts.googleapis.com/css?family=Open+Sans:600,800&quot;,&quot;/lib/prism.css&quot;,&quot;/assets/stylesheets/styles.css&quot;],&quot;localLinks&quot;:[],&quot;extend&quot;:{&quot;meta&quot;:[{&quot;name&quot;:&quot;twitter:card&quot;,&quot;content&quot;:&quot;summary&quot;},{&quot;name&quot;:&quot;twitter:site&quot;,&quot;content&quot;:&quot;@Himenon&quot;},{&quot;property&quot;:&quot;og:title&quot;,&quot;content&quot;:&quot;コンテナアプリケーション作成時のディレクトリ成長設計の考察&quot;},{&quot;property&quot;:&quot;og:url&quot;,&quot;content&quot;:&quot;https://himenon.github.io/blog/container-app-directory-management-consideration&quot;},{&quot;property&quot;:&quot;og:description&quot;,&quot;content&quot;:&quot;早くが画面から出たい人の備忘録。&quot;},{&quot;property&quot;:&quot;og:image&quot;,&quot;content&quot;:&quot;https://himenon.github.io&quot;}]}},&quot;ext&quot;:&quot;.md&quot;,&quot;filename&quot;:&quot;src/blog/container-app-directory-management-consideration.md&quot;,&quot;name&quot;:&quot;blog/container-app-directory-management-consideration&quot;,&quot;raw&quot;:&quot;---\ntitle: \&quot;コンテナアプリケーション作成時のディレクトリ成長設計の考察\&quot;\ncreatedAt: 2018-03-16 02:28:23\nupdatedAt: 2019-05-21 11:22:01\n---\n\n## はじめに\n\nDockerを使ったWEBアプリケーションのディレクトリ成長設計について考えていきます。\n\n### 提起\n\nPCを使う上で、我々の扱うデータはディレクトリ構造の中に格納されています。\nアプリケーション開発は、コーディングして、バージョン管理し、デプロイまで\n行って初めてユーザーに届きます。\n時が経過するに連れて、使用する技術やサービスの規模感が変わってきますが、\nディレクトリ構造の初期設計次第で、迅速に対応できるかどうかが決まってくると考えられます。\n\n### 課題\n\nマイクロサービスアプリケーションにおける、\nコンテナを用いたアプリケーションの\nディレクトリの成長設計の考察を具体的に行う。\n\n### 方向性\n\n「UNIXという考え方―その設計思想と哲学」の本に乗っ取り、\n以下のことを目標に考えていきます。\n\n- 小さく作る\n- 1つのプログラムには1つのことだけをやらせる\n- 試作が早く作れる状態にする\n- 効率より移植性を取る\n- すべてのプログラムをフィルタにする\n\nこれから外れる考えのものははじく方針で行います。\n\n## 解説用のアプリケーションの要件定義\n\n説明のため、予め要件定義をしておきます。\n(問題の抽象度とここの具体度がかけ離れすぎなので、気が向いたら調整)\n\n1. WEBアプリケーションを作成する\n1. 言語はPythonとする\n1. 開発環境はDockerを用いる\n1. デプロイ先はKubernetesとする\n1. KubernetesはHelmによって管理する\n1. CI/CDを用いて、自動テスト、自動デプロイを行う\n1. コードはGithubで管理する\n1. テスト駆動を行う\n1. ドキュメントを必ず残す\n1. マイクロサービスアーキテクチャを採用する\n\n## 具体的な手順に落とし込んで俯瞰する\n\n要件を満たすように、WEBアプリケーションを育ててみます。\nその時のファイル構造、ディレクトリ構造の変化を見ていきます。\nモチベーションの維持のために、「まず動かす」を前提に構築していきます。\n\n### 1. 小さなWEBアプリケーションを作成する\n\n```\n+ server.py\n```\n\nローカルでサクッと試せるアプリケーションのコードを配置します。\nファイル分割とかは後回しです。まず動かす、という部分を達成する。\n\n### 2. テストコードを追加する\n\n```\n  server.py\n+ test_server.py\n```\n\nこの段階ではまだ`test/`ディレクトリを切らないでおく。\n理由は、まずはコンテナで動かすが目標。\n\n### 3. ドキュメントを追加する\n\n```\n  server.py\n  test_server.py\n+ README.md\n```\n\ngit pullしてから、起動、テストを行う方法を書いておいたほうが良いでしょう。\nアプリの想像力の方にリソースを持っていかれるので、忘れないうちに書きます。\n\n### 4. CIの設定を組み込む\n\n```\n+ .ci_settings\n  server.py\n  test_server.py\n  README.md\n```\n\nCircle CIでもTravis CIでも良いので、まず突っ込みます。\nアプリケーションが肥大化する前に設置することが大事です。\n\n### 5. コンテナ化する\n\n```\n  .ci_settings\n+ Dockerfile\n  server.py\n  test_server.py\n  README.md\n```\n\nDockerfileは、このアプリケーションが`docker pull`したあと、\n`docker run`で立ち上がるように記述します。\n\n### 6. git cloneしたあとに立ち上げやすいようにする\n\n```\n  .ci_settings\n  Dockerfile\n+ docker-compose.yml\n  server.py\n  test_server.py\n  README.md\n```\n\n`docker-compose up`もしくは、それと同等のコマンドで、\nミドルウェアも含めたアプリケーションが全て立ち上がると開発への着手がはやい。\n\n### 7. frontendとbackendで切り分ける\n\n```\n  .ci_settings\n+ frontend/\n+   Dockerfile\n+ backend/\n    Dockerfile\n    server.py\n    test_server.py\n  docker-compose.yml # build contextの変更\n  README.md\n```\n\nFrontendとBackendのコードを分離して保守しやすい状態にします。\nマイクロサービスの下地ができました。\n\n### 8. 成長させる\n\n```\n  .ci_settings\n  frontend/\n    Dockerfile\n    ...\n  backend/\n    Dockerfile\n    server.py\n    module/\n      ...\n    test/\n      test_server.py\n  docker-compose.yml # build contextの変更\n  README.md\n```\n\n前回でディレクトリの切り分けが終わったので、あとはそれぞれのマイクロサービスを成長させるだけです。\nそれぞれのマイクロサービスでドメイン設計を行いつつ、\nディレクトリの成長設計をすると、開発者にとってもサービスにとっても良いことしかないでしょう。\n\n## まとめ\n\n成長痛を味わいますが、小さいうちに、手の届く範囲からTDDできる状態に\nディレクトリの成長設計を行っておくことで、\n肥大化するアプリケーションに対して先手を打つことができます。\n\n大規模なOSSを見たり、実際に運用されているコードを見て、\n自らの知識や理論、経験からくる構造設計と照らし合わせながら今後も考察していきたいですね。\n\n## 【余談】Dockerfileの`ENTRYPOINT`と`CMD`に関して、個人的な考察\n\nいろいろ試した結果、要件が確定していない場合や、より明確に実行コマンドを開発者に伝えるには、\n`CMD`と`ENTRYPOINT`の役割を明確化しておく必要があると考えます。\n具体的には次の2つです。\n\n1. `Dockerfile`の最後は`CMD`で終わるようにし、フォアグラウンドプロセスとして起動するようにしておく。\n1. `ENTRYPOINT`は`exec $@`を末尾に記述しておき、環境変数によって、コンテナ内部の状態が切り替わるようにしておく。\n\n比喩を用いて例えると、`CMD`は手で、`ENTRYPOINT`は腕のような感じです。\n\n直接アプリケーションを実行するのは`CMD`にしておき、\n例えば、同一のアプリケーションでも異なる立ち上げ方を試したような場合(引数などをつける)ときに、\n素のコマンドが起動時に伝わったほうが検証が早くなります。\n\n`ENTRYPOINT`の使い方は、先の検証によって導き出された設定を環境変数で切り替えることだけを考えます。\n`ENTRYPOINT`はシェルスクリプトで記述しますが、\n末尾に`exec \&quot;$@\&quot;`をつけることで、`CMD`を実行することが可能です。\nここに至る前までに、環境変数でコンテナ内部の状態を切り替えることで`CMD`の機動力を失わずに、設定を切り替えられます。\n\n1つのアプリケーションが複数の起動コマンドを持っている場合に、この2つに分離しておいたほうが良いことがわかります。\n具体的な例だと、タスクキューライブラリの`celery`を使っている時にこの事象が発生しました。\nCeleryは同一のコードで、`worker`、`scheduler`、`server`の3つの役割をもたせることができます。\n起動コマンドが異なるだけで、それ以外は全く同じです。\n\nこれを環境変数で起動コマンドを切り替えるようにすることも可能ですが、\n結局どんなコマンドで実行していたのかを確認するためには、ロジックを読まないとたどり着けず、\nそれだけで消耗してしまいます。\n\n幸いにして、`CMD`の部分は`docker-compose`は`command`であとから変更できますし、\nKubernetesも同様のことがdeploymentでできます。\n若干Portabilityの部分が下がる印象がありますが、\nそもそもアプリケーションが複数の起動パターンを持っている場合はあとから変更することが可能な状態にしておいたほうが良いと考えられます。\n\n### 反例\n\n反例は有ります。[getredash/redash](https://github.com/getredash/redash)です。\n`bin/docker-entrypoint`に起動ロジックが集約されています。\n`docker-compose.yml`は`command`を受け付けていますが、純粋なcommandではなく、引数になっています。\n(この部分、本当なら`args`を利用したほうが良いように思えますが、\n今後`docker-compose`が主流でなくなった時に`args`があるかどうかわからないのでこれはこれで正解かなと思います。)\nredashの場合、アーキテクチャが既に決まっているようなOSSになっているので、\nユーザー側にむしろ負担を強いいないような設計になっているのかな、と勝手に推測します。\n&quot;},&quot;site&quot;:{&quot;title&quot;:&quot;himenon.github.io&quot;,&quot;description&quot;:&quot;早くが画面から出たい人の備忘録。&quot;,&quot;baseUri&quot;:&quot;/&quot;,&quot;baseUrl&quot;:&quot;https://himenon.github.io&quot;}}"></script>
  </head>

  <body>

    <body>
      <div>
        <nav id="nav-bar">
          <div id="nav-bar-container"><a href="/">TOP</a></div>
        </nav>
        <header id="site-header">
          <div id="site-header-container">
            <h1 id="page-title">コンテナアプリケーション作成時のディレクトリ成長設計の考察</h1>
            <p id="page-description">早くが画面から出たい人の備忘録。</p>
            <p id="article-time"><span id="posted-at__label">投稿日</span><time>2018-03-16 11:28:23</time><span id="created-at__label">更新日</span><time>2019-05-21 08:22:01</time></p>
          </div>
        </header>
      </div>
      <div class="wrapper">
        <section>
          <h2>はじめに</h2>
          <p>Dockerを使ったWEBアプリケーションのディレクトリ成長設計について考えていきます。</p>
          <h3>提起</h3>
          <p>PCを使う上で、我々の扱うデータはディレクトリ構造の中に格納されています。
            アプリケーション開発は、コーディングして、バージョン管理し、デプロイまで
            行って初めてユーザーに届きます。
            時が経過するに連れて、使用する技術やサービスの規模感が変わってきますが、
            ディレクトリ構造の初期設計次第で、迅速に対応できるかどうかが決まってくると考えられます。</p>
          <h3>課題</h3>
          <p>マイクロサービスアプリケーションにおける、
            コンテナを用いたアプリケーションの
            ディレクトリの成長設計の考察を具体的に行う。</p>
          <h3>方向性</h3>
          <p>「UNIXという考え方―その設計思想と哲学」の本に乗っ取り、
            以下のことを目標に考えていきます。</p>
          <ul>
            <li>小さく作る</li>
            <li>1つのプログラムには1つのことだけをやらせる</li>
            <li>試作が早く作れる状態にする</li>
            <li>効率より移植性を取る</li>
            <li>すべてのプログラムをフィルタにする</li>
          </ul>
          <p>これから外れる考えのものははじく方針で行います。</p>
          <h2>解説用のアプリケーションの要件定義</h2>
          <p>説明のため、予め要件定義をしておきます。
            (問題の抽象度とここの具体度がかけ離れすぎなので、気が向いたら調整)</p>
          <ol>
            <li>WEBアプリケーションを作成する</li>
            <li>言語はPythonとする</li>
            <li>開発環境はDockerを用いる</li>
            <li>デプロイ先はKubernetesとする</li>
            <li>KubernetesはHelmによって管理する</li>
            <li>CI/CDを用いて、自動テスト、自動デプロイを行う</li>
            <li>コードはGithubで管理する</li>
            <li>テスト駆動を行う</li>
            <li>ドキュメントを必ず残す</li>
            <li>マイクロサービスアーキテクチャを採用する</li>
          </ol>
          <h2>具体的な手順に落とし込んで俯瞰する</h2>
          <p>要件を満たすように、WEBアプリケーションを育ててみます。
            その時のファイル構造、ディレクトリ構造の変化を見ていきます。
            モチベーションの維持のために、「まず動かす」を前提に構築していきます。</p>
          <h3>1. 小さなWEBアプリケーションを作成する</h3><pre class="language-plain"><code class="language-plain">+ server.py
</code></pre>
          <p>ローカルでサクッと試せるアプリケーションのコードを配置します。
            ファイル分割とかは後回しです。まず動かす、という部分を達成する。</p>
          <h3>2. テストコードを追加する</h3><pre class="language-plain"><code class="language-plain">  server.py
+ test_server.py
</code></pre>
          <p>この段階ではまだ<code>test/</code>ディレクトリを切らないでおく。
            理由は、まずはコンテナで動かすが目標。</p>
          <h3>3. ドキュメントを追加する</h3><pre class="language-plain"><code class="language-plain">  server.py
  test_server.py
+ README.md
</code></pre>
          <p>git pullしてから、起動、テストを行う方法を書いておいたほうが良いでしょう。
            アプリの想像力の方にリソースを持っていかれるので、忘れないうちに書きます。</p>
          <h3>4. CIの設定を組み込む</h3><pre class="language-plain"><code class="language-plain">+ .ci_settings
  server.py
  test_server.py
  README.md
</code></pre>
          <p>Circle CIでもTravis CIでも良いので、まず突っ込みます。
            アプリケーションが肥大化する前に設置することが大事です。</p>
          <h3>5. コンテナ化する</h3><pre class="language-plain"><code class="language-plain">  .ci_settings
+ Dockerfile
  server.py
  test_server.py
  README.md
</code></pre>
          <p>Dockerfileは、このアプリケーションが<code>docker pull</code>したあと、
            <code>docker run</code>で立ち上がるように記述します。</p>
          <h3>6. git cloneしたあとに立ち上げやすいようにする</h3><pre class="language-plain"><code class="language-plain">  .ci_settings
  Dockerfile
+ docker-compose.yml
  server.py
  test_server.py
  README.md
</code></pre>
          <p><code>docker-compose up</code>もしくは、それと同等のコマンドで、
            ミドルウェアも含めたアプリケーションが全て立ち上がると開発への着手がはやい。</p>
          <h3>7. frontendとbackendで切り分ける</h3><pre class="language-plain"><code class="language-plain">  .ci_settings
+ frontend/
+   Dockerfile
+ backend/
    Dockerfile
    server.py
    test_server.py
  docker-compose.yml # build contextの変更
  README.md
</code></pre>
          <p>FrontendとBackendのコードを分離して保守しやすい状態にします。
            マイクロサービスの下地ができました。</p>
          <h3>8. 成長させる</h3><pre class="language-plain"><code class="language-plain">  .ci_settings
  frontend/
    Dockerfile
    ...
  backend/
    Dockerfile
    server.py
    module/
      ...
    test/
      test_server.py
  docker-compose.yml # build contextの変更
  README.md
</code></pre>
          <p>前回でディレクトリの切り分けが終わったので、あとはそれぞれのマイクロサービスを成長させるだけです。
            それぞれのマイクロサービスでドメイン設計を行いつつ、
            ディレクトリの成長設計をすると、開発者にとってもサービスにとっても良いことしかないでしょう。</p>
          <h2>まとめ</h2>
          <p>成長痛を味わいますが、小さいうちに、手の届く範囲からTDDできる状態に
            ディレクトリの成長設計を行っておくことで、
            肥大化するアプリケーションに対して先手を打つことができます。</p>
          <p>大規模なOSSを見たり、実際に運用されているコードを見て、
            自らの知識や理論、経験からくる構造設計と照らし合わせながら今後も考察していきたいですね。</p>
          <h2>【余談】Dockerfileの<code>ENTRYPOINT</code>と<code>CMD</code>に関して、個人的な考察</h2>
          <p>いろいろ試した結果、要件が確定していない場合や、より明確に実行コマンドを開発者に伝えるには、
            <code>CMD</code>と<code>ENTRYPOINT</code>の役割を明確化しておく必要があると考えます。
            具体的には次の2つです。</p>
          <ol>
            <li><code>Dockerfile</code>の最後は<code>CMD</code>で終わるようにし、フォアグラウンドプロセスとして起動するようにしておく。</li>
            <li><code>ENTRYPOINT</code>は<code>exec $@</code>を末尾に記述しておき、環境変数によって、コンテナ内部の状態が切り替わるようにしておく。</li>
          </ol>
          <p>比喩を用いて例えると、<code>CMD</code>は手で、<code>ENTRYPOINT</code>は腕のような感じです。</p>
          <p>直接アプリケーションを実行するのは<code>CMD</code>にしておき、
            例えば、同一のアプリケーションでも異なる立ち上げ方を試したような場合(引数などをつける)ときに、
            素のコマンドが起動時に伝わったほうが検証が早くなります。</p>
          <p><code>ENTRYPOINT</code>の使い方は、先の検証によって導き出された設定を環境変数で切り替えることだけを考えます。
            <code>ENTRYPOINT</code>はシェルスクリプトで記述しますが、
            末尾に<code>exec &quot;$@&quot;</code>をつけることで、<code>CMD</code>を実行することが可能です。
            ここに至る前までに、環境変数でコンテナ内部の状態を切り替えることで<code>CMD</code>の機動力を失わずに、設定を切り替えられます。</p>
          <p>1つのアプリケーションが複数の起動コマンドを持っている場合に、この2つに分離しておいたほうが良いことがわかります。
            具体的な例だと、タスクキューライブラリの<code>celery</code>を使っている時にこの事象が発生しました。
            Celeryは同一のコードで、<code>worker</code>、<code>scheduler</code>、<code>server</code>の3つの役割をもたせることができます。
            起動コマンドが異なるだけで、それ以外は全く同じです。</p>
          <p>これを環境変数で起動コマンドを切り替えるようにすることも可能ですが、
            結局どんなコマンドで実行していたのかを確認するためには、ロジックを読まないとたどり着けず、
            それだけで消耗してしまいます。</p>
          <p>幸いにして、<code>CMD</code>の部分は<code>docker-compose</code>は<code>command</code>であとから変更できますし、
            Kubernetesも同様のことがdeploymentでできます。
            若干Portabilityの部分が下がる印象がありますが、
            そもそもアプリケーションが複数の起動パターンを持っている場合はあとから変更することが可能な状態にしておいたほうが良いと考えられます。</p>
          <h3>反例</h3>
          <p>反例は有ります。<a href="https://github.com/getredash/redash">getredash/redash</a>です。
            <code>bin/docker-entrypoint</code>に起動ロジックが集約されています。
            <code>docker-compose.yml</code>は<code>command</code>を受け付けていますが、純粋なcommandではなく、引数になっています。
            (この部分、本当なら<code>args</code>を利用したほうが良いように思えますが、
            今後<code>docker-compose</code>が主流でなくなった時に<code>args</code>があるかどうかわからないのでこれはこれで正解かなと思います。)
            redashの場合、アーキテクチャが既に決まっているようなOSSになっているので、
            ユーザー側にむしろ負担を強いいないような設計になっているのかな、と勝手に推測します。</p>
        </section>
      </div>
    </body>
  </body>

</html>